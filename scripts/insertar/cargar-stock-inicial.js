// scripts/insertar/cargar-stock-inicial.js - VERSI√ìN CORREGIDA PARA SUCURSAL EXISTENTE
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

// Configuraci√≥n del stock inicial - ACTUALIZADA
const CONFIGURACION = {
  sucursalId: 'sucursal-bariloche', // üî• ID espec√≠fico de la sucursal
  sucursalNombre: 'Sucursal Bariloche', // üî• Nombre exacto
  cantidadPorProducto: 1,
  motivo: 'Stock inicial para pruebas',
  // Puedes cambiar estas cantidades por categor√≠a si quieres
  cantidadPorCategoria: {
    'Aceites Corporales': 2,
    'Difusores': 3,
    'Velas de Soja': 2,
    'Jabones': 5,
    // El resto usar√° cantidadPorProducto por defecto
  }
};

// Funci√≥n CORREGIDA para obtener la sucursal existente
async function obtenerSucursalExistente() {
  console.log(`üè¢ Buscando sucursal: ${CONFIGURACION.sucursalNombre} (ID: ${CONFIGURACION.sucursalId})`);
  
  try {
    // üî• OPCI√ìN 1: Buscar por ID espec√≠fico (m√°s confiable)
    let sucursal = await prisma.ubicacion.findUnique({
      where: { id: CONFIGURACION.sucursalId }
    });
    
    if (sucursal) {
      console.log(`   ‚úÖ Sucursal encontrada por ID: ${sucursal.nombre} (${sucursal.id})`);
      console.log(`   üìç Direcci√≥n: ${sucursal.direccion}`);
      console.log(`   üìû Tel√©fono: ${sucursal.telefono}`);
      return sucursal;
    }
    
    // üî• OPCI√ìN 2: Buscar por nombre exacto como fallback
    sucursal = await prisma.ubicacion.findFirst({
      where: { 
        nombre: CONFIGURACION.sucursalNombre,
        tipo: 'sucursal'
      }
    });
    
    if (sucursal) {
      console.log(`   ‚úÖ Sucursal encontrada por nombre: ${sucursal.nombre} (${sucursal.id})`);
      console.log(`   üìç Direcci√≥n: ${sucursal.direccion}`);
      return sucursal;
    }
    
    // üî• ERROR: No se encontr√≥ la sucursal
    console.error('‚ùå Sucursal no encontrada. Opciones:');
    console.error('   1. Ejecutar primero el script de creaci√≥n de sucursales');
    console.error('   2. Verificar que el ID o nombre sean correctos');
    
    // Mostrar sucursales disponibles
    const sucursalesDisponibles = await prisma.ubicacion.findMany({
      where: { tipo: 'sucursal' },
      select: { id: true, nombre: true, activo: true }
    });
    
    if (sucursalesDisponibles.length > 0) {
      console.error('   üìã Sucursales disponibles:');
      sucursalesDisponibles.forEach(suc => {
        console.error(`      - ${suc.nombre} (ID: ${suc.id}) ${suc.activo ? '‚úÖ' : '‚ùå'}`)
      });
    }
    
    throw new Error(`Sucursal no encontrada: ${CONFIGURACION.sucursalNombre}`);
    
  } catch (error) {
    console.error('‚ùå Error al buscar sucursal:', error.message);
    throw error;
  }
}

// Funci√≥n para obtener todos los productos activos
async function obtenerProductosActivos() {
  console.log('üì¶ Obteniendo productos activos...');
  
  try {
    const productos = await prisma.producto.findMany({
      where: { activo: true },
      include: { categoria: true },
      orderBy: [
        { categoria: { nombre: 'asc' } },
        { nombre: 'asc' }
      ]
    });
    
    console.log(`   üìã Encontrados ${productos.length} productos activos`);
    
    if (productos.length === 0) {
      console.log('‚ö†Ô∏è No hay productos activos. ¬øEjecutaste el script de carga de productos?');
      return [];
    }
    
    // Mostrar resumen por categor√≠a
    const resumenCategorias = productos.reduce((acc, producto) => {
      const categoria = producto.categoria.nombre;
      acc[categoria] = (acc[categoria] || 0) + 1;
      return acc;
    }, {});
    
    console.log('   üìÇ Productos por categor√≠a:');
    Object.entries(resumenCategorias).forEach(([categoria, cantidad]) => {
      const cantidadStock = CONFIGURACION.cantidadPorCategoria[categoria] || CONFIGURACION.cantidadPorProducto;
      console.log(`      ${categoria}: ${cantidad} productos (${cantidadStock} unid. c/u)`);
    });
    
    return productos;
    
  } catch (error) {
    console.error('‚ùå Error al obtener productos:', error);
    throw error;
  }
}

// Funci√≥n para verificar stock existente
async function verificarStockExistente(sucursalId) {
  console.log('üîç Verificando stock existente...');
  
  try {
    const stockExistente = await prisma.stock.findMany({
      where: { 
        ubicacionId: sucursalId,
        productoId: { not: null } // Solo productos, no insumos
      },
      include: { 
        producto: { include: { categoria: true } }
      }
    });
    
    console.log(`   üìä Stock existente: ${stockExistente.length} productos`);
    
    if (stockExistente.length > 0) {
      console.log('   üîç Resumen de stock actual por categor√≠a:');
      const stockPorCategoria = stockExistente.reduce((acc, stock) => {
        if (stock.producto) {
          const categoria = stock.producto.categoria.nombre;
          if (!acc[categoria]) {
            acc[categoria] = { productos: 0, unidades: 0 };
          }
          acc[categoria].productos++;
          acc[categoria].unidades += stock.cantidad;
        }
        return acc;
      }, {});
      
      Object.entries(stockPorCategoria).forEach(([categoria, datos]) => {
        console.log(`      ${categoria}: ${datos.productos} productos, ${datos.unidades} unidades`);
      });
    }
    
    return stockExistente;
    
  } catch (error) {
    console.error('‚ùå Error al verificar stock existente:', error);
    return [];
  }
}

// Funci√≥n para crear stock para un producto
async function crearStockProducto(sucursalId, producto, cantidad, usuarioId) {
  try {
    // Verificar si ya existe stock para este producto
    const stockExistente = await prisma.stock.findFirst({
      where: {
        ubicacionId: sucursalId,
        productoId: producto.id
      }
    });
    
    if (stockExistente) {
      // Actualizar stock existente
      const stockActualizado = await prisma.stock.update({
        where: { id: stockExistente.id },
        data: { 
          cantidad: stockExistente.cantidad + cantidad,
          ultimaActualizacion: new Date()
        }
      });
      
      // Crear movimiento de stock
      await prisma.movimientoStock.create({
        data: {
          stockId: stockActualizado.id,
          tipoMovimiento: 'entrada',
          cantidad: cantidad,
          motivo: CONFIGURACION.motivo,
          usuarioId: usuarioId,
          fecha: new Date()
        }
      });
      
      return { 
        tipo: 'actualizado', 
        stockAnterior: stockExistente.cantidad, 
        stockNuevo: stockActualizado.cantidad,
        cantidadAgregada: cantidad
      };
    } else {
      // Crear nuevo stock
      const nuevoStock = await prisma.stock.create({
        data: {
          ubicacionId: sucursalId,
          productoId: producto.id,
          cantidad: cantidad,
          ultimaActualizacion: new Date()
        }
      });
      
      // Crear movimiento de stock
      await prisma.movimientoStock.create({
        data: {
          stockId: nuevoStock.id,
          tipoMovimiento: 'entrada',
          cantidad: cantidad,
          motivo: CONFIGURACION.motivo,
          usuarioId: usuarioId,
          fecha: new Date()
        }
      });
      
      return { tipo: 'creado', stockNuevo: cantidad };
    }
    
  } catch (error) {
    console.error(`‚ùå Error creando stock para ${producto.nombre}:`, error);
    throw error;
  }
}

// Funci√≥n para obtener o crear usuario admin para los movimientos
async function obtenerUsuarioAdmin() {
  try {
    let usuario = await prisma.user.findFirst({
      where: { 
        roleId: 'role-admin',
        email: 'admin@test.com'
      }
    });
    
    if (!usuario) {
      // Si no existe, buscar cualquier admin
      usuario = await prisma.user.findFirst({
        where: { roleId: 'role-admin' }
      });
    }
    
    if (!usuario) {
      throw new Error('No se encontr√≥ usuario admin. Ejecuta primero el script de seed de usuarios.');
    }
    
    return usuario;
  } catch (error) {
    console.error('‚ùå Error al obtener usuario admin:', error);
    throw error;
  }
}

// Funci√≥n principal para cargar stock
async function cargarStockInicial(sobreescribir = false) {
  console.log('üì¶ === CARGA DE STOCK INICIAL PARA SUCURSAL BARILOCHE ===\n');
  
  try {
    // 1. üî• CORREGIDO: Obtener sucursal existente
    const sucursal = await obtenerSucursalExistente();
    
    // 2. Obtener usuario admin
    const usuario = await obtenerUsuarioAdmin();
    console.log(`üë§ Usuario para movimientos: ${usuario.name} (${usuario.email})`);
    
    // 3. Verificar stock existente
    const stockExistente = await verificarStockExistente(sucursal.id);
    
    if (stockExistente.length > 0 && !sobreescribir) {
      console.log('\n‚ö†Ô∏è Ya existe stock en esta sucursal.');
      console.log('üí° Opciones:');
      console.log('   1. Ejecutar con --sobreescribir para sumar al stock existente');
      console.log('   2. Limpiar el stock primero con --limpiar');
      return { resultado: 'cancelado', motivo: 'stock_existente' };
    }
    
    // 4. Obtener productos
    const productos = await obtenerProductosActivos();
    
    if (productos.length === 0) {
      console.log('‚ùå No se encontraron productos activos para cargar stock');
      console.log('üí° Ejecuta primero: node scripts/insertar/insertar-productos-completos.js');
      return { resultado: 'error', motivo: 'sin_productos' };
    }
    
    // 5. Cargar stock para cada producto
    console.log('\nüì¶ Cargando stock inicial...');
    
    let creados = 0;
    let actualizados = 0;
    let errores = 0;
    let totalUnidadesAgregadas = 0;
    const erroresDetalle = [];
    
    for (const producto of productos) {
      try {
        // Determinar cantidad seg√∫n categor√≠a
        const categoria = producto.categoria.nombre;
        const cantidad = CONFIGURACION.cantidadPorCategoria[categoria] || CONFIGURACION.cantidadPorProducto;
        
        // Crear/actualizar stock
        const resultado = await crearStockProducto(sucursal.id, producto, cantidad, usuario.id);
        
        if (resultado.tipo === 'creado') {
          console.log(`   ‚úÖ ${producto.nombre}: ${cantidad} unidades (nuevo)`);
          creados++;
        } else {
          console.log(`   üîÑ ${producto.nombre}: ${resultado.stockAnterior} ‚Üí ${resultado.stockNuevo} unidades (+${resultado.cantidadAgregada})`);
          actualizados++;
        }
        
        totalUnidadesAgregadas += cantidad;
        
      } catch (error) {
        console.error(`   ‚ùå Error con ${producto.nombre}: ${error.message}`);
        errores++;
        erroresDetalle.push(`${producto.nombre}: ${error.message}`);
      }
    }
    
    // 6. Mostrar resumen
    console.log('\nüìä === RESUMEN DE CARGA DE STOCK ===');
    console.log(`üè¢ Sucursal: ${sucursal.nombre} (${sucursal.id})`);
    console.log(`‚úÖ Stock creado: ${creados} productos`);
    console.log(`üîÑ Stock actualizado: ${actualizados} productos`);
    console.log(`üì¶ Total unidades agregadas: ${totalUnidadesAgregadas}`);
    console.log(`‚ùå Errores: ${errores}`);
    console.log(`üìã Total procesado: ${productos.length} productos`);
    
    if (errores > 0) {
      console.log('\n‚ùå Errores detallados:');
      erroresDetalle.forEach(error => console.log(`   - ${error}`));
    }
    
    // 7. Verificar el stock final por categor√≠a
    console.log('\nüìÇ Stock final por categor√≠a:');
    const stockFinal = await prisma.stock.findMany({
      where: { 
        ubicacionId: sucursal.id,
        productoId: { not: null }
      },
      include: { 
        producto: { 
          include: { categoria: true }
        }
      }
    });
    
    const resumenStockFinal = stockFinal.reduce((acc, stock) => {
      if (stock.producto) {
        const categoria = stock.producto.categoria.nombre;
        if (!acc[categoria]) {
          acc[categoria] = { productos: 0, totalUnidades: 0 };
        }
        acc[categoria].productos++;
        acc[categoria].totalUnidades += stock.cantidad;
      }
      return acc;
    }, {});
    
    Object.entries(resumenStockFinal).forEach(([categoria, datos]) => {
      console.log(`   ${categoria}: ${datos.productos} productos, ${datos.totalUnidades} unidades totales`);
    });
    
    // 8. Muestra de productos con m√°s stock
    console.log('\nüîù Top 5 productos con m√°s stock:');
    const topStock = stockFinal
      .sort((a, b) => b.cantidad - a.cantidad)
      .slice(0, 5);
    
    topStock.forEach((stock, index) => {
      if (stock.producto) {
        console.log(`   ${index + 1}. ${stock.producto.nombre}: ${stock.cantidad} unidades`);
      }
    });
    
    return {
      resultado: 'exitoso',
      sucursal: sucursal.nombre,
      sucursalId: sucursal.id,
      creados,
      actualizados,
      errores,
      totalProcesado: productos.length,
      totalUnidadesAgregadas
    };
    
  } catch (error) {
    console.error('‚ùå Error general:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

// Funci√≥n para limpiar stock existente
async function limpiarStock() {
  console.log(`üßπ Limpiando stock de ${CONFIGURACION.sucursalNombre}...`);
  
  try {
    const sucursal = await obtenerSucursalExistente();
    
    // Eliminar movimientos de stock
    const movimientos = await prisma.movimientoStock.deleteMany({
      where: {
        stock: { 
          ubicacionId: sucursal.id,
          productoId: { not: null } // Solo productos
        }
      }
    });
    
    // Eliminar stock
    const stock = await prisma.stock.deleteMany({
      where: { 
        ubicacionId: sucursal.id,
        productoId: { not: null } // Solo productos
      }
    });
    
    console.log(`   ‚úÖ Eliminados ${movimientos.count} movimientos`);
    console.log(`   ‚úÖ Eliminados ${stock.count} registros de stock`);
    
  } catch (error) {
    console.error('‚ùå Error limpiando stock:', error);
    throw error;
  }
}

// Ejecutar si es llamado directamente
if (require.main === module) {
  const args = process.argv.slice(2);
  const sobreescribir = args.includes('--sobreescribir');
  const limpiar = args.includes('--limpiar');
  
  if (limpiar) {
    console.log('üßπ MODO LIMPIAR ACTIVADO');
    limpiarStock()
      .then(() => {
        console.log('\n‚úÖ Stock limpiado correctamente');
        process.exit(0);
      })
      .catch((error) => {
        console.error('\n‚ùå Error limpiando stock:', error);
        process.exit(1);
      });
  } else {
    if (sobreescribir) {
      console.log('üîÑ MODO SOBREESCRIBIR ACTIVADO - Se sumar√° al stock existente');
    }
    
    cargarStockInicial(sobreescribir)
      .then((resultado) => {
        if (resultado.resultado === 'exitoso') {
          console.log('\nüéâ === CARGA DE STOCK COMPLETADA ===');
          console.log(`üì¶ ${resultado.totalUnidadesAgregadas} unidades agregadas en ${resultado.sucursal}`);
          console.log(`‚úÖ ${resultado.creados + resultado.actualizados} productos procesados`);
        } else {
          console.log(`\n‚ö†Ô∏è Carga cancelada: ${resultado.motivo}`);
        }
        process.exit(0);
      })
      .catch((error) => {
        console.error('\nüí• === ERROR EN LA CARGA DE STOCK ===');
        console.error(error);
        process.exit(1);
      });
  }
}

module.exports = { 
  cargarStockInicial,
  limpiarStock,
  obtenerSucursalExistente
};